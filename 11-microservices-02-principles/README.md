# Домашнее задание к занятию "11.02 Микросервисы: принципы"

## Модуль 11. Микросервисная архитектура

### Студент: Иван Жиляев

>Вы работаете в крупной компанию, которая строит систему на основе микросервисной архитектуры.
>Вам как DevOps специалисту необходимо обеспечить настройку систем для обеспечения работы системы.


## Задача 1: API Gateway

>### Есть три сервиса:
>
>**minio**
>- Хранит загруженные файлы в бакете images
>- S3 протокол
>
>**uploader**
>- Принимает файл, если он картинка сжимает и загружает его в minio
>- POST /v1/upload
>
>**security**
>- Регистрация пользователя POST /v1/user
>- Получение информации о пользователе GET /v1/user
>- Логин пользователя POST /v1/token
>- Проверка токена GET /v1/token/validation
>
>### Необходимо воспользоваться любым балансировщиком и сделать API Gateway:
>
>**POST /v1/register**
>- Анонимный доступ.
>- Запрос направляется в сервис security POST /v1/user
>
>**POST /v1/token**
>- Анонимный доступ.
>- Запрос направляется в сервис security POST /v1/token
>
>**GET /v1/user**
>- Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
>- Запрос направляется в сервис security GET /v1/user
>
>**POST /v1/upload**
>- Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
>- Запрос направляется в сервис uploader POST /v1/upload
>
>**GET /v1/user/{image}**
>- Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
>- Запрос направляется в сервис minio  GET /images/{image}
>
>### Ожидаемый результат
>
>Результатом выполнения задачи должен быть docker compose файл запустив который можно локально выполнить следующие команды с успешным результатом.
>Предполагается что для реализации API Gateway будет написан конфиг для NGinx или другого балансировщика нагрузки который будет запущен как сервис через docker-compose и будет обеспечивать балансировку и проверку аутентификации входящих запросов.
>Авторизаци
>curl -X POST -H 'Content-Type: application/json' -d '{"login":"bob", "password":"qwe123"}' http://localhost/token
>
>**Загрузка файла**
>
>curl -X POST -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2IifQ.hiMVLmssoTsy1MqbmIoviDeFPvo-nCd92d4UFiN2O2I' -H 'Content-Type: octet/stream' --data-binary @yourfilename.jpg http://localhost/upload
>
>**Получение файла**
>curl -X GET http://localhost/images/4e6df220-295e-4231-82bc-45e4b1484430.jpg


Вспомогательные материалы, шедшие с заданием, я разместил в папке [help](./help/).

Как оказалось, сервис **security** не имеет реализации методов `POST /v1/user` и `GET /v1/user` - это сперва сбило с толку. Убедиться можно изучив [исходный код](help/security/src/server.py).

Также возникли затруднения с логикой принятия решения внутри API Gateway об авторизации клиента: сервис **security** `GET /v1/token/validation/` даже на некорректный токен возвращал ответ с кодом http 200, сообщая об ошибке лишь в теле ответа.  
Было принято решение изменить [исходный код](help/security/src/server.py) сервиса **security**, чтобы код http 200 явно свидетельствовал об успешной проверке. 

Для решения вопроса с авторизацией клиента я добавил следующие локейшены в конфигурацию nginx :
- `location = /auth { ... }` для отправки запросов для валидации токена от клиента
- `location /check { ... }` для контроля работы процедуры авторизации в качестве модуля принятия решения
- `location @verified { ... }` для контроля работы процедуры авторизации в качестве контрольного защищённого контента

Основа логики ограничения доступа - модуль [`auth_request`](https://nginx.org/ru/docs/http/ngx_http_auth_request_module.html), который уже добавлен в используемом образе `nginx:alpine`. Суть его работы в отправке подзапроса для авторизации и анализ кода ответа: если это 2xx, то доступ разрешается, в остальных случаях - запрещается.

При написании конфигурации nginx я в первую очередь опирался на "Ожидаемый результат", а не на описание маршрутов API Gateway. Пришлось установить этот приоритет из-за расхождения требований в тексте задания.

Сервер nginx отказывался распознавать имя сервиса **storage**, хотя в контейнере с ним пинг успешно резолвил это имя. Текст ошибка был:
```
no resolver defined to resolve storage
```
Решение - добавил в конфигурацию в секцию server опцию "`resolver 127.0.0.11;`", т.е. установку обращаться к стандартному резолверу docker`а.

По окончании настройки я смог провести следующую проверку:
- получить токен командой 
    ```
    curl -X POST -H 'Content-Type: application/json' -d '{"login":"bob", "password":"qwe123"}' http://localhost/token
    ```
- провести upload картинки командой 
    ```
    curl -X POST -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2IifQ.hiMVLmssoTsy1MqbmIoviDeFPvo-nCd92d4UFiN2O2I' -H 'Content-Type: octet/stream' --data-binary @duck.jpeg http://localhost/upload
    ```
- скачать картинку используя выданное предшествующей командой назначенное имя файла 
    ```
    curl -X GET http://localhost/images/5105dfff-b2e8-43b3-9f38-af0715806423.jpg
    ```
